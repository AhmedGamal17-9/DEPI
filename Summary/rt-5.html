<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="description" content="">
  <meta name="keywords" content="">
  <link rel="stylesheet" href="assets/Css/tetorial.css">
  <title>React 5</title>
</head>
<body>
 <div id="header"></div>
  <pre class="prew">
    1:04:00
ğŸ“Œ What is useEffect?

  â— It is a Hook that allows you to perform side effects in functional components After rendering or when certain values change.
  
  â— Side effects are operations that occur outside the normal flow of data in the component.
  
  â— Side effects are any operation that occurs "outside" the main UI.
<hr>ğŸ“Œ Why do we use it?

  â— Without useEffect, any code you put in a component's function will be executed immediately every time a render occurs, which can cause problems:
    o An infinite loop occurs (for example, fetching data causes => change in state, causing => re-render component forever).
    o Difficulty controlling when the code runs and when it stops.

  â— useEffect helps you tell React:
    o Run this code after rendering.
    o Run this code only the first time.
    o Run this code every time a certain value changes.

  â— Examples of side effects that we use useEffect to do it:
    o Directly manipulating the DOM.
      â—change &lt;title&gt;.  
    o Data fetching (API calls).
    o Subscribing to events
      â— WepSocket
      â— window.addEventListener
      â— window resize
      â— scroll
    o Running a timer
      â— setTimeout
      â— setInterval
    o Handling localStorage. 

  â— AbortController API
    o js object to control or delete any asynchronous operations (fetch,wep,steam) without waiting for it to finish.
      â— 1. create controller
<pre>
const controller = new AbortController();
</pre>
      â— 2. take signal of controller => to tracking API like fetch to know when cancel it
      â— 3. We put signal inside asynchronous operation
      â— 4. Sometimes we need to do more than one thing with cancellation, not just stop the asynchronous operation (cleanup)
<pre>
const signal = controller.signal;

signal.addEventListener('abort', 
  () => { 
    //âŒ The request was canceled, clean up the resources here!
  }
); 

fetch(url, {signal});
</pre>     
      â— 5. .abort() => Method to cancel asynchronous operation :
The first thing that happens is : signal.aborted === true .
The second thing that happens is : Any asynchronous operation associated with it will be stopped immediately.
The last thing that happens is : it throws a special Error called AbortError.
This error is not due to a problem with the internet or the server. We cancelled the order ourselves.
We catch this error in the catch() and ignore it.
we're telling react: If the error was caused by us canceling the operation â†’ do nothing (ignore it).
<pre>
controller.abort();
      â¬‡ï¸
if (err.name === 'AbortError') { 
  // ignore
}
</pre>

<hr>ğŸ“Œ How do we use it?

  â— Syntax : useEffect(callback function, dependency array)
    o A callback function: This function contains the logic for the side effect.
    o An optional dependency array: This array controls when the effect runs.

  â— Ø­Ø§Ù„Ø§ØªÙ‡Ø§
    o If the dependency array is not provided
      â— useEffect(()=>{})
      â— The effect runs after every render
    o If the dependency array is an empty array
      â— useEffect(()=>{}, [])
      â— The effect runs only once after the initial render
    o If the dependency array is contains values
      â— The effect runs after the initial render and whenever any of the values in the dependency array change
      â— useEffect(()=>{}, [prop1, state2])

<hr>ğŸ“Œ What is Cleanup function? 

  â— If your effect needs to clean up resources ( unsubscribe from an event, clear a timer, WebSocket Subscription).

  â— you can <b style="font-size: x-large;">return</b> a cleanup-function in the <b style="font-size: x-large;">callback function</b> to do it.

  â— This cleanup function <b style="font-size: x-large;">runs in two cases</b> :
    o before the component unmounts
    o before the effect runs again due to a dependency change  

<hr>ğŸ”¹ Why do we need it?

  â— Prevent resource consumption

  â— Prevent memory leaks (unnecessary memory consumption).

  â— Life Analogy ğŸ  : Imagine you entered a room and turned on the light.
    o useEffect = You turned on the light.
    o Cleanup = Before you leave, you must turn off the light so it doesn't stay on for nothing.

<pre>
import { useEffect, useState } from 'react';

function Timer() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    // This effect runs once after the initial render (empty dependency array)
    const intervalId = setInterval(() => {
      setCount(prevCount => prevCount + 1);
    }, 1000);

    // Cleanup function: This runs once when the component unmounts
    return () => {
      clearInterval(intervalId);
    };
  }, []); // Empty dependency array means all code runs once

  return (
    &lt;div&gt;
      &lt;p&gt;Timer: {count} seconds&lt;/p&gt;
    &lt;/div&gt;
  );
}
</pre><hr>
ğŸ“Œ The callback function inside useEffect must be synchronous.

  â— React expects the return from useEffect to be either void (undefined) or a cleanup function.

  â— If you async the callback function, it will return a Promise, which is not what React wants.

  â— So we write a regular callback function with an async IIFE function inside it.
<hr>
ğŸ“Œ why we use IIFE?
 
  â— IIFE = Immediately Invoked Function Expression
  â— Sometimes I want to write a function and run it Immediately â†’ without needing to give it a name or call it later.
  â— Execute code only once
  â— we want to write await / async function in useEffect
  â— Syntax : 
<pre>
(function () {
  console.log('Immediately run');
})();
</pre>
    o The first two parentheses (function(){â€¦}) â†’ make the code to treat it as an expression rather than a declaration.
    o The last two parentheses () â†’ mean to run the function immediately.
</pre>
<pre class="prew">
  what I learned to build :
    Use.jsx
    P-example.jsx
    C-example.jsx
    T-example.jsx
</pre>
    <script>
    fetch("header.html")
      .then(res => res.text())
      .then(data => {
        document.getElementById("header").innerHTML = data;
      });
  </script>
</body>
</html>