<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="description" content="">
  <meta name="keywords" content="">
  <link rel="stylesheet" href="assets/Css/tetorial.css">
  <title>js 6</title>
</head>
<body>
 <div id="header"></div>
    <p id="demo"></p>
    <h2>ğŸ”Open js 6.js to view Practical Examples (Code in Action)</h2>
  <pre class="prew">
- Initially, code execution in JavaScript was <b style="font-size: x-large;">Synchronous (sequential) :</b>
  â— This means that the next line wouldn't run until the previous one finished.
  â— Any function wouldn't start until the one before it finished completely.
  â— This meant you couldn't pause a process and start something else (such as waiting for a data download or a response from the server) and then resume normally.
- This is where the concept of <b style="font-size: x-large;">Callback</b> comes in:
  â— function passed as an argument to another function.
  â— <b>to be executed at a later time (we don't want it run immediately)   &lt;========================= ğŸ‘€ Important</b> 
  â— If we want to use a function as an argument,
    o Normal-function 
      ğŸŸ¢ Pass it as a Reference *Function-Name* without brackets().
    o Arrow-function , are often preferred for callbacks
      ğŸŸ¢ Case 1: Pass it directly as an Anonymous function *Arrow-function* in the place of the call .
      ğŸ”µ Case 2: store it in a variable and then pass that variable
<hr><!--------------------------------------------------------------------------------------------->   
- setTimeout and setInterval are essentially callback-based APIs (meaning they are built on callbacks).

- setInterval(function,time in milliseconds) : 
   1-Bilt-in function execute another function repeatedly every certain period of time.
   <pre>
    var x = setInterval(y,1000);
    function y () {
      // code }
    --------------------------------
    var x = setInterval(y(){},1000);
   </pre>
   2- clearInterval(variable name) : stop the setInterval functio.

-- setTimeout(function,time in milliseconds) :
    1- Bilt-in function execute another function after certain period of time.
   <pre>
    var x = setTimeout(y,1000);
    function y () {
      // code }
    --------------------------------
    var x = setTimeout(y(){},1000);
   </pre>
<hr><!--------------------------------------------------------------------------------------------->
- But two problems appeared: Callback Hell and the delay that occurs as a result of waiting. 
- This is where the concept of <b style="font-size: x-large;">asynchronous ØºÙŠØ± Ù…ØªØ²Ø§Ù…Ù†ÙŠÙ† \ Ù…Ø­Ø¯Ø´ Ø¨ÙŠØ³ØªÙ†ÙŠ Ø§Ù„ØªØ§Ù†ÙŠ </b> comes in:
-JavaScript doesn't wait for a long-running operation, 
it starts it and completes the rest of the code, 
and when the operation is finished,
it returns to executing the associated code (using callback, promises, or async/await).   
<hr><!--------------------------------------------------------------------------------------------->    
<b style="font-size: x-large;">Promise</b>
    - object that represents asynchronous operation, and its resulting value.
    - ğŸ“Œ What makes me write Promise?
      â— The main reason: When I have a process that will take a long time (asynchronous) and 
                         I don't want to stop the entire program waiting for it,
                         a Promise provides a cleaner and more organized way to handle the result "when it arrives" or "if an error occurs."
      â— Without a Promise, you would have to write a callback inside a callback (which we call Callback Hell).
      â— Examples:
        o Fetching data from an API (fetch, axios).
        o Reading/writing files (in Node.js).
        o Time delays (setTimeout, setInterval).
        o Handling multiple processes simultaneously   
    - has 3 cases : pending---fulfilled or success---rejected or failure
    - have function inside it that take 2 parameters (resolve, reject)
    - use .then( resolve() ) method to handle success case
    - resolve() : function argument in .then()
    - use .catch( reject() ) method to handle failur case    
    - reject()  : function argument in .catch() 
    - can chain multiple .then() and .catch() methods to run operations in sequence and handle errors if they occur.
    <pre>
let myPromise = new Promise(
function(resolve, reject) {
  // asynchronous operation
  resolve();
  reject();
})
.then()
.catch();

//       or

let myPromise = new Promise(
  function(resolve, reject) {
    // asynchronous operation
    resolve();
    reject();
  });
myPromise.then().catch();
    </pre>
<hr><!--------------------------------------------------------------------------------------------->    
<b style="font-size: x-large;">fetch("URL",{options})</b>

- A built-in JavaScript function used to make an HTTP request (like GET or POST) from our code to somewhere else (e.g., an API or a server) and handle responses asynchronously .

- return promise (**response object**), which means we need to use .then or await to know the result.

- Syntax :
    â— url : the link to which we will send the request.
    â— options (optional to write): An object that contains the settings for the request such as :
      o method
        â— POST : send new data to the server.
        â— PUT : modifies or updates existing data entirely.
        â— PATCH : modifies a portion of the data.
        â— DELETE : deletes data (no body).
        â— GET : retrieves data from the server (no body).
      o header
        â— Sends additional information to the server about the request or <strong>the data type</strong>.
        â— The headers value must be object (key: value).
      o body
        â— Data sent with the request (only with POST, PUT, and PATCH).
        â— Must be a string, FormData, Blob, or Buffer.
      o signal
        â— Sometimes you want to cancel an order if it takes too long or the user has changed their mind.
        â—  You can cancel the order using AbortController.

- The response object contains information about the HTTP response (**Properties**), not the actual data.

  â— status :
    o The code number returned from the server (HTTP status code).

  â— response.ok : 
    o Boolean property in response object
    o that returns true if the HTTP response status code is in the range 200-299 (successful response)
    o Otherwise false

  â— response.json() : 
    o To access the data, you need to parse the JSON body(string) to JavaScript object.
    o converts JSON text from the response into a JavaScript object
    o Function returns a Promise, so you need to write await to get the data.
<pre>
fetch("https://example.com")
.then(response => response.json())
.then(data => console.log(data))
// { id: 1, name: "Ahmed" }
.catch(error => console.error(error));
----------------OR----------------------
const res = await fetch("https://example.com");
const data = await res.json();
console.log(data);
// { id: 1, name: "Ahmed" }
</pre>    
<hr><!--------------------------------------------------------------------------------------------->    
<b style="font-size: x-large;">async + await</b>
1- async :
  - ğŸ“Œ Why we use async?
    â— When the function handles something that won't return a result immediately (asynchronous operation),
      we will use promis, Instead of writing 
<pre>
function(){
  return myPromise = new Promise(
    function(resolve, reject) {
    // asynchronous operation
    resolve();
    reject(); }
  )
.then()
.catch(); 
}
</pre>
      async will Makes any function automatic returns Promise.resolve() or Promise.reject() automatically.
    â— automatic define if it is fulfilled or rejected
    â— It gives us an advantage: using the function in other async functions by await.    
    â— If you don't use async â†’ you have to write a nested .then(), which is complicated
      instead, in async we use try/catch it is better to manage, especially if you have more than one await.    
    â— Examples:
      o Fetching data from an API (fetch, axios).
      o Reading/writing files (in Node.js).
      o Dealing with databases (MongoDB, MySQL, etc.).
      o Time delays (setTimeout, setInterval).
      o Any operation that is heavy or relies on system resources.    
<pre>
function test1() {
  return Promise.resolve(5);
}
console.log(typeof test1); // function
console.log(typeof test1()); // object
test1().then(x => console.log(typeof x)); //numper
--------------------------------
async function test2() {
  return 5;
}
console.log(typeof test2); // function
console.log(typeof test2()); // object
</pre>
    â— âš ï¸ Important
    â— async isn't "magic".
    â— It only understands two things:
    â— If function return a normal value, 
      o it puts it inside an async-Promise  Ø¨Ù…Ø¹Ù†ÙŠ :  Async takes what is inside the return and puts it in async-Promise immediately without executing it.
    â— If function return a Promise, it waits it to finish and returns its output inside an async-Promise.
<pre>
async function f3() {
  return (resolve) => {
    setTimeout(() => resolve("rs : 2"), 2000);
  };
}  
console.log(f3());
// console output :
// â–¼ Promise {&lt;fulfilled&gt;: f}
      [[Prototype]]: Promise
      [[PromiseState]]: "fulfilled"
      [[PromiseResult]]: (resolve) => {...}
---------------------------------------------------------------------------------------------      
async function getNumber() {
  return new Promise(
    (resolve,reject) => {
      setTimeout(
        () => resolve("rs : 2"), 2000
      );
      setTimeout(
        () => reject("rj : 3"), 3000
      );      
    }
  );
};
console.log(getNumber());
// console output :
// â–¼ Promise {&lt;pending&gt;}
      [[Prototype]]: Promise
      [[PromiseState]]: "fulfilled"
      [[PromiseResult]]: "rs2"
</pre>
2-await :
  - can only be used with promise inside an async function
  - makes JavaScript pauses execution until the Promise is resolved (or rejected), before running the next line
  - makes your code look and behave like synchronous code

  </pre>
<pre class="prew">
- Date() : Built-in object in JS 
  â— Its function: handles time and dates (year, month, day, hour, minute, second, etc.).

  â— It can retrieve the current date, create a new date from it, or modify existing dates.

  â— create object :
    o Current date and current time
<pre>
let now = new Date();
console.log(now);
// Fri Oct 03 2025 14:35:10 GMT+0200 (Eastern European Standard Time)
</pre>
    o On a specific date (String):
<pre>
let d = new Date("2025-12-25");
console.log(d);
// Thu Dec 25 2025
</pre> 
    o On a specific date (numbers):
<pre>
// Year, Month, Day, Hour, Minute, Second
let d = new Date(2025, 11, 25, 10, 30, 0);
console.log(d);
// Thu Dec 25 2025 10:30:00
</pre> 

  â— have Methods inside it
    o Data.now()
      â— Returns an integer representing the current time, calculated in milliseconds, from the beginning of the "epoch time" until now.
      â— epoch time : This is the beginning of computer calculations: January 1, 1970, at 00:00:00 UTC.

    o Data.getTime() : method that returns the number of milliseconds since "epoch time"
<hr>
- Error() : Built-in object in JS

  â— Its function: represents runtime errors and exceptions in JavaScript.  

  â— It helps developers identify, describe, and handle errors in code.  
    o Each error object contains a **message** and a **name**, and sometimes a **stack trace**.  

  â— create object :
    o Simple error:
<pre>
let err = new Error("Something went wrong!");
console.log(err);
// Error: Something went wrong!
</pre>
    o Throw an error:
<pre>
throw new Error("Something went wrong!");
</pre>
  â— Common properties inside Error object
    o name
      â— Returns the type of error.
      â— Example:
<pre>
let err = new Error("Failed!");
console.log(err.name); // "Error"
</pre>
    o message
      â— The text message passed when creating the error.
      â— Example:
<pre>
let err = new Error("Failed!");
console.log(err.message); // "Failed!"
</pre>
    o stack
      â— A string describing where the error is in the code.
      â— Useful for debugging.
<pre>
let err = new Error("Debugging...");
console.log(err.stack);
// Shows call stack and where error occurred
</pre>

  â— Handling errors with try...catch
<pre>
try {
  throw new Error("Something went wrong!");
} catch (e) {
  console.log("Caught error:", e.message); 
}
// Output: Caught error: Something went wrong!
</pre>
<hr>
- Math.floor() : round a number DOWN to the nearest integer{ex: 4.7 => 4}
<hr>
- Web APIs : Application Programming Interface
  â— enable communication between client (browser) and server over HTTP
<hr>
- Examples of endpoints:
    * https://jsonplaceholder.typicode.com/posts
    * https://api.github.com/users/octocat
    * https://reqres.in/api/users
    * https://dog.ceo/api/breeds/image/random
</pre>
<ul id="ul"></ul>
<button id="btn">click</button>

  <script src="assets/JS/js 6.js"></script>
    <script>
    fetch("header.html")
      .then(res => res.text())
      .then(data => {
        document.getElementById("header").innerHTML = data;
      });
  </script>
</body>
</html>