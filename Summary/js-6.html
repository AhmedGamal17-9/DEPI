<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="description" content="">
  <meta name="keywords" content="">
  <link rel="stylesheet" href="assets/Css/tetorial.css">
  <title>js 6</title>
</head>
<body>
 <div id="header"></div>
    <p id="demo"></p>
    <h2>🔎Open js 6.js to view Practical Examples (Code in Action)</h2>
  <pre class="prew">
- Initially, code execution in JavaScript was <b style="font-size: x-large;">Synchronous (sequential) :</b>
  ● This means that the next line wouldn't run until the previous one finished.
  ● Any function wouldn't start until the one before it finished completely.
  ● This meant you couldn't pause a process and start something else (such as waiting for a data download or a response from the server) and then resume normally.
- This is where the concept of <b style="font-size: x-large;">Callback</b> comes in:
  ● function passed as an argument to another function.
  ● <b>to be executed at a later time (we don't want it run immediately)   &lt;========================= 👀 Important</b> 
  ● If we want to use a function as an argument,
    o Normal-function 
      🟢 Pass it as a Reference *Function-Name* without brackets().
    o Arrow-function , are often preferred for callbacks
      🟢 Case 1: Pass it directly as an Anonymous function *Arrow-function* in the place of the call .
      🔵 Case 2: store it in a variable and then pass that variable
<hr><!--------------------------------------------------------------------------------------------->   
- setTimeout and setInterval are essentially callback-based APIs (meaning they are built on callbacks).

- setInterval(function,time in milliseconds) : 
   1-Bilt-in function execute another function repeatedly every certain period of time.
   <pre>
    var x = setInterval(y,1000);
    function y () {
      // code }
    --------------------------------
    var x = setInterval(y(){},1000);
   </pre>
   2- clearInterval(variable name) : stop the setInterval functio.

-- setTimeout(function,time in milliseconds) :
    1- Bilt-in function execute another function after certain period of time.
   <pre>
    var x = setTimeout(y,1000);
    function y () {
      // code }
    --------------------------------
    var x = setTimeout(y(){},1000);
   </pre>
<hr><!--------------------------------------------------------------------------------------------->
- But two problems appeared: Callback Hell and the delay that occurs as a result of waiting. 
- This is where the concept of <b style="font-size: x-large;">asynchronous غير متزامنين \ محدش بيستني التاني </b> comes in:
-JavaScript doesn't wait for a long-running operation, 
it starts it and completes the rest of the code, 
and when the operation is finished,
it returns to executing the associated code (using callback, promises, or async/await).   
<hr><!--------------------------------------------------------------------------------------------->    
<b style="font-size: x-large;">Promise</b>
    - object that represents asynchronous operation, and its resulting value.
    - 📌 What makes me write Promise?
      ● The main reason: When I have a process that will take a long time (asynchronous) and 
                         I don't want to stop the entire program waiting for it,
                         a Promise provides a cleaner and more organized way to handle the result "when it arrives" or "if an error occurs."
      ● Without a Promise, you would have to write a callback inside a callback (which we call Callback Hell).
      ● Examples:
        o Fetching data from an API (fetch, axios).
        o Reading/writing files (in Node.js).
        o Time delays (setTimeout, setInterval).
        o Handling multiple processes simultaneously   
    - has 3 cases : pending---fulfilled or success---rejected or failure
    - have function inside it that take 2 parameters (resolve, reject)
    - use .then( resolve() ) method to handle success case
    - resolve() : function argument in .then()
    - use .catch( reject() ) method to handle failur case    
    - reject()  : function argument in .catch() 
    - can chain multiple .then() and .catch() methods to run operations in sequence and handle errors if they occur.
    <pre>
let myPromise = new Promise(
function(resolve, reject) {
  // asynchronous operation
  resolve();
  reject();
})
.then()
.catch();

//       or

let myPromise = new Promise(
  function(resolve, reject) {
    // asynchronous operation
    resolve();
    reject();
  });
myPromise.then().catch();
    </pre>
<hr><!--------------------------------------------------------------------------------------------->    
<b style="font-size: x-large;">fetch("URL",{options})</b>

- A built-in JavaScript function used to make an HTTP request (like GET or POST) from our code to somewhere else (e.g., an API or a server) and handle responses asynchronously .

- return promise (**response object**), which means we need to use .then or await to know the result.

- Syntax :
    ● url : the link to which we will send the request.
    ● options (optional to write): An object that contains the settings for the request such as :
      o method
        ◎ POST : send new data to the server.
        ◎ PUT : modifies or updates existing data entirely.
        ◎ PATCH : modifies a portion of the data.
        ◎ DELETE : deletes data (no body).
        ◎ GET : retrieves data from the server (no body).
      o header
        ◎ Sends additional information to the server about the request or <strong>the data type</strong>.
        ◎ The headers value must be object (key: value).
      o body
        ◎ Data sent with the request (only with POST, PUT, and PATCH).
        ◎ Must be a string, FormData, Blob, or Buffer.
      o signal
        ◎ Sometimes you want to cancel an order if it takes too long or the user has changed their mind.
        ◎  You can cancel the order using AbortController.

- The response object contains information about the HTTP response (**Properties**), not the actual data.

  ● status :
    o The code number returned from the server (HTTP status code).

  ● response.ok : 
    o Boolean property in response object
    o that returns true if the HTTP response status code is in the range 200-299 (successful response)
    o Otherwise false

  ● response.json() : 
    o To access the data, you need to parse the JSON body(string) to JavaScript object.
    o converts JSON text from the response into a JavaScript object
    o Function returns a Promise, so you need to write await to get the data.
<pre>
fetch("https://example.com")
.then(response => response.json())
.then(data => console.log(data))
// { id: 1, name: "Ahmed" }
.catch(error => console.error(error));
----------------OR----------------------
const res = await fetch("https://example.com");
const data = await res.json();
console.log(data);
// { id: 1, name: "Ahmed" }
</pre>    
<hr><!--------------------------------------------------------------------------------------------->    
<b style="font-size: x-large;">async + await</b>
1- async :
  - 📌 Why we use async?
    ● When the function handles something that won't return a result immediately (asynchronous operation),
      we will use promis, Instead of writing 
<pre>
function(){
  return myPromise = new Promise(
    function(resolve, reject) {
    // asynchronous operation
    resolve();
    reject(); }
  )
.then()
.catch(); 
}
</pre>
      async will Makes any function automatic returns Promise.resolve() or Promise.reject() automatically.
    ● automatic define if it is fulfilled or rejected
    ● It gives us an advantage: using the function in other async functions by await.    
    ● If you don't use async → you have to write a nested .then(), which is complicated
      instead, in async we use try/catch it is better to manage, especially if you have more than one await.    
    ● Examples:
      o Fetching data from an API (fetch, axios).
      o Reading/writing files (in Node.js).
      o Dealing with databases (MongoDB, MySQL, etc.).
      o Time delays (setTimeout, setInterval).
      o Any operation that is heavy or relies on system resources.    
<pre>
function test1() {
  return Promise.resolve(5);
}
console.log(typeof test1); // function
console.log(typeof test1()); // object
test1().then(x => console.log(typeof x)); //numper
--------------------------------
async function test2() {
  return 5;
}
console.log(typeof test2); // function
console.log(typeof test2()); // object
</pre>
    ● ⚠️ Important
    ● async isn't "magic".
    ● It only understands two things:
    ● If function return a normal value, 
      o it puts it inside an async-Promise  بمعني :  Async takes what is inside the return and puts it in async-Promise immediately without executing it.
    ● If function return a Promise, it waits it to finish and returns its output inside an async-Promise.
<pre>
async function f3() {
  return (resolve) => {
    setTimeout(() => resolve("rs : 2"), 2000);
  };
}  
console.log(f3());
// console output :
// ▼ Promise {&lt;fulfilled&gt;: f}
      [[Prototype]]: Promise
      [[PromiseState]]: "fulfilled"
      [[PromiseResult]]: (resolve) => {...}
---------------------------------------------------------------------------------------------      
async function getNumber() {
  return new Promise(
    (resolve,reject) => {
      setTimeout(
        () => resolve("rs : 2"), 2000
      );
      setTimeout(
        () => reject("rj : 3"), 3000
      );      
    }
  );
};
console.log(getNumber());
// console output :
// ▼ Promise {&lt;pending&gt;}
      [[Prototype]]: Promise
      [[PromiseState]]: "fulfilled"
      [[PromiseResult]]: "rs2"
</pre>
2-await :
  - can only be used with promise inside an async function
  - makes JavaScript pauses execution until the Promise is resolved (or rejected), before running the next line
  - makes your code look and behave like synchronous code

  </pre>
<pre class="prew">
- Date() : Built-in object in JS 
  ● Its function: handles time and dates (year, month, day, hour, minute, second, etc.).

  ● It can retrieve the current date, create a new date from it, or modify existing dates.

  ● create object :
    o Current date and current time
<pre>
let now = new Date();
console.log(now);
// Fri Oct 03 2025 14:35:10 GMT+0200 (Eastern European Standard Time)
</pre>
    o On a specific date (String):
<pre>
let d = new Date("2025-12-25");
console.log(d);
// Thu Dec 25 2025
</pre> 
    o On a specific date (numbers):
<pre>
// Year, Month, Day, Hour, Minute, Second
let d = new Date(2025, 11, 25, 10, 30, 0);
console.log(d);
// Thu Dec 25 2025 10:30:00
</pre> 

  ● have Methods inside it
    o Data.now()
      ◎ Returns an integer representing the current time, calculated in milliseconds, from the beginning of the "epoch time" until now.
      ◎ epoch time : This is the beginning of computer calculations: January 1, 1970, at 00:00:00 UTC.

    o Data.getTime() : method that returns the number of milliseconds since "epoch time"
<hr>
- Error() : Built-in object in JS

  ● Its function: represents runtime errors and exceptions in JavaScript.  

  ● It helps developers identify, describe, and handle errors in code.  
    o Each error object contains a **message** and a **name**, and sometimes a **stack trace**.  

  ● create object :
    o Simple error:
<pre>
let err = new Error("Something went wrong!");
console.log(err);
// Error: Something went wrong!
</pre>
    o Throw an error:
<pre>
throw new Error("Something went wrong!");
</pre>
  ● Common properties inside Error object
    o name
      ◎ Returns the type of error.
      ◎ Example:
<pre>
let err = new Error("Failed!");
console.log(err.name); // "Error"
</pre>
    o message
      ◎ The text message passed when creating the error.
      ◎ Example:
<pre>
let err = new Error("Failed!");
console.log(err.message); // "Failed!"
</pre>
    o stack
      ◎ A string describing where the error is in the code.
      ◎ Useful for debugging.
<pre>
let err = new Error("Debugging...");
console.log(err.stack);
// Shows call stack and where error occurred
</pre>

  ● Handling errors with try...catch
<pre>
try {
  throw new Error("Something went wrong!");
} catch (e) {
  console.log("Caught error:", e.message); 
}
// Output: Caught error: Something went wrong!
</pre>
<hr>
- Math.floor() : round a number DOWN to the nearest integer{ex: 4.7 => 4}
<hr>
- Web APIs : Application Programming Interface
  ● enable communication between client (browser) and server over HTTP
<hr>
- Examples of endpoints:
    * https://jsonplaceholder.typicode.com/posts
    * https://api.github.com/users/octocat
    * https://reqres.in/api/users
    * https://dog.ceo/api/breeds/image/random
</pre>
<ul id="ul"></ul>
<button id="btn">click</button>

  <script src="assets/JS/js 6.js"></script>
    <script>
    fetch("header.html")
      .then(res => res.text())
      .then(data => {
        document.getElementById("header").innerHTML = data;
      });
  </script>
</body>
</html>