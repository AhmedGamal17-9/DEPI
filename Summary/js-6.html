<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="description" content="">
  <meta name="keywords" content="">
  <link rel="stylesheet" href="assets/Css/tetorial.css">
  <title>js 6</title>
</head>
<body>
 <div id="header"></div>
    <p id="demo"></p>
    <h2>ğŸ”Open js 6.js to view Practical Examples (Code in Action)</h2>
  <pre class="prew">
- Initially, code execution in JavaScript was <b style="font-size: x-large;">Synchronous (sequential) :</b>
  â— This means that the next line wouldn't run until the previous one finished.
  â— Any function wouldn't start until the one before it finished completely.
  â— This meant you couldn't pause a process and start something else (such as waiting for a data download or a response from the server) and then resume normally.
- This is where the concept of <b style="font-size: x-large;">Callback</b> comes in:
  â— function passed as an argument to another function.
  â— <b>to be executed at a later time (we don't want it run immediately)   &lt;========================= ğŸ‘€ Important</b> 
  â— If we want to use a function as an argument,
    o Normal-function 
      ğŸŸ¢ Pass it as a Reference *Function-Name* without brackets().
    o Arrow-function , are often preferred for callbacks
      ğŸŸ¢ Case 1: Pass it directly as an Anonymous function *Arrow-function* in the place of the call .
      ğŸ”µ Case 2: store it in a variable and then pass that variable
<hr><!--------------------------------------------------------------------------------------------->   
- setTimeout and setInterval are essentially callback-based APIs (meaning they are built on callbacks).

- setInterval(function,time in milliseconds) : 
   1-Bilt-in function execute another function repeatedly every certain period of time.
   <pre>
    var x = setInterval(y,1000);
    function y () {
      // code }
    --------------------------------
    var x = setInterval(y(){},1000);
   </pre>
   2- clearInterval(variable name) : stop the setInterval functio.

-- setTimeout(function,time in milliseconds) :
    1- Bilt-in function execute another function after certain period of time.
   <pre>
    var x = setTimeout(y,1000);
    function y () {
      // code }
    --------------------------------
    var x = setTimeout(y(){},1000);
   </pre>
<hr><!--------------------------------------------------------------------------------------------->
- But two problems appeared: Callback Hell and the delay that occurs as a result of waiting. 
- This is where the concept of <b style="font-size: x-large;">asynchronous ØºÙŠØ± Ù…ØªØ²Ø§Ù…Ù†ÙŠÙ† \ Ù…Ø­Ø¯Ø´ Ø¨ÙŠØ³ØªÙ†ÙŠ Ø§Ù„ØªØ§Ù†ÙŠ </b> comes in:
-JavaScript doesn't wait for a long-running operation, 
it starts it and completes the rest of the code, 
and when the operation is finished,
it returns to executing the associated code (using callback, promises, or async/await).   
<hr><!--------------------------------------------------------------------------------------------->    
<b style="font-size: x-large;">Promise</b>
    - object that represents asynchronous operation, and its resulting value.
    - ğŸ“Œ What makes me write Promise?
      â— The main reason: When I have a process that will take a long time (asynchronous) and 
                         I don't want to stop the entire program waiting for it,
                         a Promise provides a cleaner and more organized way to handle the result "when it arrives" or "if an error occurs."
      â— Without a Promise, you would have to write a callback inside a callback (which we call Callback Hell).
      â— Examples:
        o Fetching data from an API (fetch, axios).
        o Reading/writing files (in Node.js).
        o Time delays (setTimeout, setInterval).
        o Handling multiple processes simultaneously   
    - has 3 cases : pending---fulfilled or success---rejected or failure
    - have function inside it that take 2 parameters (resolve, reject)
    - use .then( resolve() ) method to handle success case
    - resolve() : function argument in .then()
    - use .catch( reject() ) method to handle failur case    
    - reject()  : function argument in .catch() 
    - can chain multiple .then() and .catch() methods to run operations in sequence and handle errors if they occur.
    <pre>
let myPromise = new Promise(
function(resolve, reject) {
  // asynchronous operation
  resolve();
  reject();
})
.then()
.catch();

//       or

let myPromise = new Promise(
  function(resolve, reject) {
    // asynchronous operation
    resolve();
    reject();
  });
myPromise.then().catch();
    </pre>
<hr><!--------------------------------------------------------------------------------------------->    
<b style="font-size: x-large;">fetch("URL")</b>
- return promise
- Used to make HTTP requests and handle responses asynchronously.
- The response object contains information about the HTTP response, not the actual data.
- response.ok : property that returns true if the HTTP response status code is in the range 200-299 (successful response), otherwise false
- To access the data, you need to use response.json() to parse the JSON body(JSON text).
- response.json() : converts JSON text from the response into a JavaScript object
- It is a tool in JavaScript that allows you to connect to the API.
<pre>
  fetch("https://example.com")
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error(error));
</pre>    
<hr><!--------------------------------------------------------------------------------------------->    
<b style="font-size: x-large;">async + await</b>
1- async :
  - ğŸ“Œ Why we use async?
    â— When the function handles something that won't return a result immediately (asynchronous operation),
      we will use promis, Instead of writing 
<pre>
function(){
  return myPromise = new Promise(
    function(resolve, reject) {
    // asynchronous operation
    resolve();
    reject(); }
  )
.then()
.catch(); 
}
</pre>
      async will Makes any function automatic returns Promise.resolve() or Promise.reject() automatically.
    â— automatic define if it is fulfilled or rejected
    â— It gives us an advantage: using the function in other async functions by await.    
    â— If you don't use async â†’ you have to write a nested .then(), which is complicated
      instead, in async we use try/catch it is better to manage, especially if you have more than one await.    
    â— Examples:
      o Fetching data from an API (fetch, axios).
      o Reading/writing files (in Node.js).
      o Dealing with databases (MongoDB, MySQL, etc.).
      o Time delays (setTimeout, setInterval).
      o Any operation that is heavy or relies on system resources.    
<pre>
function test1() {
  return Promise.resolve(5);
}
console.log(typeof test1); // function
console.log(typeof test1()); // object
test1().then(x => console.log(typeof x)); //numper
--------------------------------
async function test2() {
  return 5;
}
console.log(typeof test2); // function
console.log(typeof test2()); // object
</pre>
    â— âš ï¸ Important
    â— async isn't "magic".
    â— It only understands two things:
    â— If function return a normal value, 
      o it puts it inside an async-Promise  Ø¨Ù…Ø¹Ù†ÙŠ :  Async takes what is inside the return and puts it in async-Promise immediately without executing it.
    â— If function return a Promise, it waits it to finish and returns its output inside an async-Promise.
<pre>
async function f3() {
  return (resolve) => {
    setTimeout(() => resolve("rs : 2"), 2000);
  };
}  
console.log(f3());
// console output :
// â–¼ Promise {&lt;fulfilled&gt;: f}
      [[Prototype]]: Promise
      [[PromiseState]]: "fulfilled"
      [[PromiseResult]]: (resolve) => {...}
---------------------------------------------------------------------------------------------      
async function getNumber() {
  return new Promise(
    (resolve,reject) => {
      setTimeout(
        () => resolve("rs : 2"), 2000
      );
      setTimeout(
        () => reject("rj : 3"), 3000
      );      
    }
  );
};
console.log(getNumber());
// console output :
// â–¼ Promise {&lt;pending&gt;}
      [[Prototype]]: Promise
      [[PromiseState]]: "fulfilled"
      [[PromiseResult]]: "rs2"
</pre>
2-await :
  - can only be used with promise inside an async function
  - makes JavaScript pauses execution until the Promise is resolved (or rejected), before running the next line
  - makes your code look and behave like synchronous code

  </pre>
<pre class="prew">
 1- new Data() : create a new date object with date and time -- empty, current date and time , or specific date and time
 2- .get time() : method that returns the number of milliseconds since January 1, 1970
 3- Math.floor() : round a number DOWN to the nearest integer{ex: 4.7 => 4}
4- Web APIs : Application Programming Interface
  - enable communication between client (browser) and server over HTTP
  -Examples of endpoints:
    * https://jsonplaceholder.typicode.com/posts
    * https://api.github.com/users/octocat
    * https://reqres.in/api/users
    * https://dog.ceo/api/breeds/image/random
</pre>
<ul id="ul"></ul>
<button id="btn">click</button>

  <script src="assets/JS/js 6.js"></script>
    <script>
    fetch("header.html")
      .then(res => res.text())
      .then(data => {
        document.getElementById("header").innerHTML = data;
      });
  </script>
</body>
</html>