<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="description" content="">
  <meta name="keywords" content="">
  <link rel="stylesheet" href="assets/Css/tetorial.css">
  <title>React 1</title>
</head>
<body>
 <div id="header"></div>
  <pre class="prew">    
- Create React Project :
  ● npm  create  vite@latest  react-project-name
  ● cd react-project-path
  ● npm install
<hr><!--------------------------------------------------------------------------------------------->
- Run React Project :
  ● cd react-project-path
  ● npm run dev
<hr><!--------------------------------------------------------------------------------------------->
- node_module : The folder that stores all the libraries and dependencies you have installed in the project.

- public
  ● The folder that stores static files that don't change or are subject to the build tool.
  ● Everything here remains accessible as it is on the server.

  - src :The most important folder (your code).
  ● assets
    o You can place images, CSS files, or any other static items in it, but you want to import them into your code.
    o The difference between it and public/: what's being processed here is
  ● app.jsx
    o It is the root component.
    o contains the basic components of the application.
    o It often contains the basic layout of the page.
  ● main.jsx
    o It is called only once to run &lt;App /&gt;.
    o This is the main entry point for the application.
    o Call to ReactDOM.createRoot(...)
    o Render &lt;App /&gt; inside the #root element in index.html.
  ● app.css  
  ● index.css : Global CSS file

- .gitignore

- eslint.config.js : ESLint configuration file (a tool that helps you detect errors in your code and keep your code organized).

- index.html
  ● You'll find a div with an ID named "root," and React renders the entire application inside it.
  ● Vite uses this file as the launcher for the application.

- package-lock.json : It locks the library versions so that anyone who runs {npm install} will get the exact same version.

- package.json   

- README.md 

- vite.config.js
<hr><!--------------------------------------------------------------------------------------------->
- Previously React relied on Class Components.
  ● To use state or track lifecycles (mount, update, unmount)
  ● you had to write a class and use this.setState.

- Problem:
  ● The code was more complex.
  ● You need to understand OOP concepts well.
  ● It's difficult to partition logic and reuse it between components.

- Change (React 16.8):
  ● Hooks were added (such as useState, useEffect, etc.).
  ● Hooks allowed you to write the same capabilities (state + lifecycle) but inside Function Components.

  - Current State:
  ● Function Components are simpler and clearer.
  ● You can write UI + logic inside regular functions.
  ● Most new projects now use Function Components instead of Classes.
<hr><!--------------------------------------------------------------------------------------------->
  ● All parts of the project are divided into pages in Function Component.
  ● App.jsx is the first function will called.
  ● App.jsx is the basic Component.
  ● Other pages must import in App.jsx then call in it
  ● main.jsx => App.jsx =>root(index.html) =>  useState 
<hr><!--------------------------------------------------------------------------------------------->
- StrictMode 
  ● is a development tool that helps you discover potential issues in your code, 
  ● all of its work is visible in development mode only.
<hr><!--------------------------------------------------------------------------------------------->
- componant
  ● Code that displays the UI.
  ● similar to a function that returns HTML with JS logic inside.
  ● Types:
    o Function Component (popular now) .
    o Class Component (old, had lifecycle methods and OOP body).
  ● give us Reusability of componant
    o ex : create 4 product card
    o create one componant
    o Reuse that componant 4 times
<hr><!--------------------------------------------------------------------------------------------->
- Virtual DOM :
  ● React doesn't constantly modify the real DOM.
  ● Instead:
    o We write JSX 
    o Then React creates a virtual DOM (a lightweight version of the DOM).
    o When the state changes, React performs a virtual re-render of the component and calculates the difference (diff) between the old and new virtual DOM.
    o It then applies the smallest possible changes to the real DOM , which improves performance over updating the entire DOM every time.
  ● This process is called reconciliation, and the diff algorithm determines what changes.
<hr><!--------------------------------------------------------------------------------------------->
- jsx 
  ● JSX (JavaScript XML) is the part inside return() only.
  ● It lets you write HTML code inside JavaScript/React files.
  ● Finally, it's converted to regular JavaScript code using Babel (or any compiler).
  ● Combines JavaScript logic + HTML syntax in one place.
  ● You can put any JavaScript expression between { }
  ● You must write Attributes HTML in : camelCase
  ● Any JSX component must return only one element, So we use:
    o &lt;div&gt; &lt;div/&gt; as a container
    o React.Fragment &lt;&gt; &lt;/&gt;
  ● There is no direct if/else statement in JSX, We use JavaScript Ternary Operator
<pre>{condition ? true : false}</pre>
  ● There is no direct for-loop in JSX, We Use array.map and assign a key to each item in a object.
  ● Array.map(function)
    o map() is a built-in function in JavaScript
    o It iterates over each element in the array and applies the function you give it.
    o returns a new array containing the results
    o 👀 Important: It doesn't change the original.
<pre>
array.map(
  (element, index, array) => {
  // element = العنصر الحالي
  // index
  // array   = نفس الـ array الأصلي
})
<hr> 
const items = [
  { id: 1, text: "Apple" },
  { id: 2, text: "Banana" },
  { id: 3, text: "Orange" }
];

function App() {
  return (
    &lt;ul&gt;
      {
      items.map(
        item => ( &lt;li key={item.id}&gt; {item.text} &lt;/li&gt; )
      )
      }
    &lt;ul/&gt;
  );
}

</pre>

The key should be constant and unique for each item.
Using an index can be problematic if the list changes.

<pre>
const items = ["Apple", "Banana", "Orange"];
const list = (
   &lt;ul&gt;
    {
    items.map(
      item => &lt;li key={item}&gt; {item} &lt;/li&gt;
    )
    }
  &lt;ul/&gt; 
);
</pre>  
  ● any tag must have close :
<pre>
&lt;&gt;&lt;/&gt;
or
&lt;/&gt;    
</pre>
  ● JSX is not understood by the browser.
  ● It is transformed to js by using Babel.lip.
  ● <strong>👀 Important : </strong>Any code outside return() is just plain JavaScript. You can write if, for, while, switch, or anything else in JavaScript.  
<hr><!--------------------------------------------------------------------------------------------->    
📌👀 Important : calling functions in jsx :

- If I want it to run immediately as soon as the component is render or re-render.
    o Any-function 
      🟢 Call it by Reference *Function-Name* with brackets().

- If I want it to 
                  run only when they need to be called. 
                  run at a later time and we don't want React call the function immediately when the JSX renders
  ● ex : inside event handlers like onClick or onChange
    o Normal-function 
      🟢 Case 1: If the function does not need arguments ➡️ Pass it as a Reference *Function-Name* without brackets().
<pre>
function App() {
  function handleClick() {
    console.log("Button clicked!");
  }

  return (
    &lt;&gt;
      &lt;button onClick={handleClick}&gt; Click &lt;/button&gt;
    &lt;/&gt;
  );
}
</pre>
      🟢 Case 2: If the function does need arguments ➡️ calling it in a callback function Pass it as a Reference *Function-Name* with brackets().
      🔵 Here, we're calling a callback function → React stores it, and when the event happens, it's executed.
<pre>
function App() {
  function handleClick(para) {
    console.log(para);
  }

  return (
    &lt;&gt;
      &lt;button onClick={() => handleClick('argu')}&gt; Click &lt;/button&gt;
    &lt;/&gt;
  );
}
</pre>
    o Arrow-function , are often preferred for callbacks
      🟢 Case 1: Pass it directly as an Anonymous function *Arrow-function* in the place of the call .
<pre>
function App() {
  return (
    &lt;&gt;
    &lt;button onClick={() => console.log("Clicked!")}&gt; Click &lt;/button&gt;
    &lt;/&gt;
  );
}  
</pre>
      🟢 Case 2: store it in a variable and then pass that variable
<pre>
function App() {
  let handleClick= ()=> {
    console.log("Button clicked!");
  }

  return (
    &lt;&gt;
      &lt;button onClick={handleClick}&gt; Click &lt;/button&gt;
    &lt;/&gt;
  );
}
</pre>  
<hr><!--------------------------------------------------------------------------------------------->
- ES Modules in JavaScript
  ● In JS, we can split code into files and export/import
  ● Import:
<pre>
import sum from './sum.js';             // default //
import { name, age } from './info.js';  // named   //
import sum, { name } from './file.js';  // both    //
</pre>  
  ● Named export:
<pre>
export const name = "ahmed";
export const age = 22;
// or
const name = "ahmed";
const age = 22;
export { name, age };  
</pre>  
  ● Default export:
<pre>
const sum = () => { /*...*/ }
export default sum;
</pre>

  ● In index.html, if you want to use ES Module files directly in the browser:
<pre>&lt;script type="module" src=""&gt;&lt;script/&gt;</pre>

</pre>
<pre class="prew">
  what I learned to build :
  react-project content
  Header.jsx
  Card.jsx
  App.jsx
</pre>
    <script>
    fetch("header.html")
      .then(res => res.text())
      .then(data => {
        document.getElementById("header").innerHTML = data;
      });
  </script>
</body>
</html>