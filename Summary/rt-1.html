<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="description" content="">
  <meta name="keywords" content="">
  <link rel="stylesheet" href="assets/Css/tetorial.css">
  <title>React 1</title>
</head>
<body>
 <div id="header"></div>
  <pre class="prew">    
- Create React Project :
  â— npm  create  vite@latest  react-project-name
  â— cd react-project-path
  â— npm install
<hr><!--------------------------------------------------------------------------------------------->
- Run React Project :
  â— cd react-project-path
  â— npm run dev
<hr><!--------------------------------------------------------------------------------------------->
- node_module : The folder that stores all the libraries and dependencies you have installed in the project.

- public
  â— The folder that stores static files that don't change or are subject to the build tool.
  â— Everything here remains accessible as it is on the server.

  - src :The most important folder (your code).
  â— assets
    o You can place images, CSS files, or any other static items in it, but you want to import them into your code.
    o The difference between it and public/: what's being processed here is
  â— app.jsx
    o It is the root component.
    o contains the basic components of the application.
    o It often contains the basic layout of the page.
  â— main.jsx
    o It is called only once to run &lt;App /&gt;.
    o This is the main entry point for the application.
    o Call to ReactDOM.createRoot(...)
    o Render &lt;App /&gt; inside the #root element in index.html.
  â— app.css  
  â— index.css : Global CSS file

- .gitignore

- eslint.config.js : ESLint configuration file (a tool that helps you detect errors in your code and keep your code organized).

- index.html
  â— You'll find a div with an ID named "root," and React renders the entire application inside it.
  â— Vite uses this file as the launcher for the application.

- package-lock.json : It locks the library versions so that anyone who runs {npm install} will get the exact same version.

- package.json   

- README.md 

- vite.config.js
<hr><!--------------------------------------------------------------------------------------------->
- Previously React relied on Class Components.
  â— To use state or track lifecycles (mount, update, unmount)
  â— you had to write a class and use this.setState.

- Problem:
  â— The code was more complex.
  â— You need to understand OOP concepts well.
  â— It's difficult to partition logic and reuse it between components.

- Change (React 16.8):
  â— Hooks were added (such as useState, useEffect, etc.).
  â— Hooks allowed you to write the same capabilities (state + lifecycle) but inside Function Components.

  - Current State:
  â— Function Components are simpler and clearer.
  â— You can write UI + logic inside regular functions.
  â— Most new projects now use Function Components instead of Classes.
<hr><!--------------------------------------------------------------------------------------------->
  â— All parts of the project are divided into pages in Function Component.
  â— App.jsx is the first function will called.
  â— App.jsx is the basic Component.
  â— Other pages must import in App.jsx then call in it
  â— main.jsx => App.jsx =>root(index.html) =>  useState 
<hr><!--------------------------------------------------------------------------------------------->
- StrictMode 
  â— is a development tool that helps you discover potential issues in your code, 
  â— all of its work is visible in development mode only.
<hr><!--------------------------------------------------------------------------------------------->
- componant
  â— Code that displays the UI.
  â— similar to a function that returns HTML with JS logic inside.
  â— Types:
    o Function Component (popular now) .
    o Class Component (old, had lifecycle methods and OOP body).
  â— give us Reusability of componant
    o ex : create 4 product card
    o create one componant
    o Reuse that componant 4 times
<hr><!--------------------------------------------------------------------------------------------->
- Virtual DOM :
  â— React doesn't constantly modify the real DOM.
  â— Instead:
    o We write JSX 
    o Then React creates a virtual DOM (a lightweight version of the DOM).
    o When the state changes, React performs a virtual re-render of the component and calculates the difference (diff) between the old and new virtual DOM.
    o It then applies the smallest possible changes to the real DOM , which improves performance over updating the entire DOM every time.
  â— This process is called reconciliation, and the diff algorithm determines what changes.
<hr><!--------------------------------------------------------------------------------------------->
- jsx 
  â— JSX (JavaScript XML) is the part inside return() only.
  â— It lets you write HTML code inside JavaScript/React files.
  â— Finally, it's converted to regular JavaScript code using Babel (or any compiler).
  â— Combines JavaScript logic + HTML syntax in one place.
  â— You can put any JavaScript expression between { }
  â— You must write Attributes HTML in : camelCase
  â— Any JSX component must return only one element, So we use:
    o &lt;div&gt; &lt;div/&gt; as a container
    o React.Fragment &lt;&gt; &lt;/&gt;
  â— There is no direct if/else statement in JSX, We use JavaScript Ternary Operator
<pre>{condition ? true : false}</pre>
  â— There is no direct for-loop in JSX, We Use array.map and assign a key to each item in a object.
  â— Array.map(function)
    o map() is a built-in function in JavaScript
    o It iterates over each element in the array and applies the function you give it.
    o returns a new array containing the results
    o ğŸ‘€ Important: It doesn't change the original.
<pre>
array.map(
  (element, index, array) => {
  // element = Ø§Ù„Ø¹Ù†ØµØ± Ø§Ù„Ø­Ø§Ù„ÙŠ
  // index
  // array   = Ù†ÙØ³ Ø§Ù„Ù€ array Ø§Ù„Ø£ØµÙ„ÙŠ
})
<hr> 
const items = [
  { id: 1, text: "Apple" },
  { id: 2, text: "Banana" },
  { id: 3, text: "Orange" }
];

function App() {
  return (
    &lt;ul&gt;
      {
      items.map(
        item => ( &lt;li key={item.id}&gt; {item.text} &lt;/li&gt; )
      )
      }
    &lt;ul/&gt;
  );
}

</pre>

The key should be constant and unique for each item.
Using an index can be problematic if the list changes.

<pre>
const items = ["Apple", "Banana", "Orange"];
const list = (
   &lt;ul&gt;
    {
    items.map(
      item => &lt;li key={item}&gt; {item} &lt;/li&gt;
    )
    }
  &lt;ul/&gt; 
);
</pre>  
  â— any tag must have close :
<pre>
&lt;&gt;&lt;/&gt;
or
&lt;/&gt;    
</pre>
  â— JSX is not understood by the browser.
  â— It is transformed to js by using Babel.lip.
  â— <strong>ğŸ‘€ Important : </strong>Any code outside return() is just plain JavaScript. You can write if, for, while, switch, or anything else in JavaScript.  
<hr><!--------------------------------------------------------------------------------------------->    
ğŸ“ŒğŸ‘€ Important : calling functions in jsx :

- If I want it to run immediately as soon as the component is render or re-render.
    o Any-function 
      ğŸŸ¢ Call it by Reference *Function-Name* with brackets().

- If I want it to 
                  run only when they need to be called. 
                  run at a later time and we don't want React call the function immediately when the JSX renders
  â— ex : inside event handlers like onClick or onChange
    o Normal-function 
      ğŸŸ¢ Case 1: If the function does not need arguments â¡ï¸ Pass it as a Reference *Function-Name* without brackets().
<pre>
function App() {
  function handleClick() {
    console.log("Button clicked!");
  }

  return (
    &lt;&gt;
      &lt;button onClick={handleClick}&gt; Click &lt;/button&gt;
    &lt;/&gt;
  );
}
</pre>
      ğŸŸ¢ Case 2: If the function does need arguments â¡ï¸ calling it in a callback function Pass it as a Reference *Function-Name* with brackets().
      ğŸ”µ Here, we're calling a callback function â†’ React stores it, and when the event happens, it's executed.
<pre>
function App() {
  function handleClick(para) {
    console.log(para);
  }

  return (
    &lt;&gt;
      &lt;button onClick={() => handleClick('argu')}&gt; Click &lt;/button&gt;
    &lt;/&gt;
  );
}
</pre>
    o Arrow-function , are often preferred for callbacks
      ğŸŸ¢ Case 1: Pass it directly as an Anonymous function *Arrow-function* in the place of the call .
<pre>
function App() {
  return (
    &lt;&gt;
    &lt;button onClick={() => console.log("Clicked!")}&gt; Click &lt;/button&gt;
    &lt;/&gt;
  );
}  
</pre>
      ğŸŸ¢ Case 2: store it in a variable and then pass that variable
<pre>
function App() {
  let handleClick= ()=> {
    console.log("Button clicked!");
  }

  return (
    &lt;&gt;
      &lt;button onClick={handleClick}&gt; Click &lt;/button&gt;
    &lt;/&gt;
  );
}
</pre>  
<hr><!--------------------------------------------------------------------------------------------->
- ES Modules in JavaScript
  â— In JS, we can split code into files and export/import
  â— Import:
<pre>
import sum from './sum.js';             // default //
import { name, age } from './info.js';  // named   //
import sum, { name } from './file.js';  // both    //
</pre>  
  â— Named export:
<pre>
export const name = "ahmed";
export const age = 22;
// or
const name = "ahmed";
const age = 22;
export { name, age };  
</pre>  
  â— Default export:
<pre>
const sum = () => { /*...*/ }
export default sum;
</pre>

  â— In index.html, if you want to use ES Module files directly in the browser:
<pre>&lt;script type="module" src=""&gt;&lt;script/&gt;</pre>

</pre>
<pre class="prew">
  what I learned to build :
  react-project content
  Header.jsx
  Card.jsx
  App.jsx
</pre>
    <script>
    fetch("header.html")
      .then(res => res.text())
      .then(data => {
        document.getElementById("header").innerHTML = data;
      });
  </script>
</body>
</html>