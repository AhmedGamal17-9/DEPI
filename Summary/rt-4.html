<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="description" content="">
  <meta name="keywords" content="">
  <link rel="stylesheet" href="assets/Css/tetorial.css">
  <title>React 4</title>
</head>
<body>
 <div id="header"></div>
  <pre class="prew">
<h2>lazy initialization in useState</h2>
- When we create useState â¡ï¸ React takes the initialValue and sets it to state.
- However: 
  â— If the initialValue is simple (like a number or a small array), no problem.
  â— If the initialValue is the result of a heavy calculation or a function call, it will run every time the component is re-render (even if state doesn't change!).
- ğŸŸ¢ Example :
<pre>
import { useState } from 'react'

export default function Counter() {

  function heavyCalculation() {
    console.log("Heavy calculation running...");
    return 1000; // Assume it returned a number after a heavy calculation
  }

  const [count, setCount] = useState(heavyCalculation());

  return (
    &lt;div&gt;
    &lt;p&gt;{count}&lt;/p&gt;
    &lt;button onClick={() => setCount(c => c + 1)}&gt; + &lt;/button&gt;
    &lt;/div&gt;
  );
}
</pre >
  â— ğŸ” What happens here?
    o âœ… On the first render, heavyCalculation() runs.
    o âŒ On every re-render (due to any other state), heavyCalculation() runs again unnecessarily.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------    
<h3>With Lazy Initialization</h3>
- if we want react doesn't execute initialValue every time re-render
- execute it only once at the first render, and then stores the value.
- ğŸ”µ Example :
<pre>
import { useState } from 'react'

export default function Counter() {

  function heavyCalculation() {
    console.log("Heavy Calculation is running...");
    return 1000;
  }

  const [count, setCount] = useState(() => heavyCalculation());

  return (
    &lt;div&gt;
    &lt;p&gt;{count}&lt;/p&gt;
    &lt;button onClick={() => setCount(c => c + 1)}&gt; + &lt;/button&gt;
    &lt;/div&gt;
  );
}

</pre >
  â— ğŸ” What happens here?
    o The first time the component is rendered, React will execute this function and return the value (1000).
    o Subsequent times (re-render) will not run it again.

- ğŸ“Œ Summary
  â— useState(value): Calculates the value every render (even if it's not used).
  â— useState(() => value): Calculates it only once (lazy initialization).
  â— If the value is simple, the two are the same.
  â— If the value is heavy, it's better to use a function for performance.
<hr><!--------------------------------------------------------------------------------------------->
ğŸ“Œ What is prop?
  â— Prop = Short of Properties.
  â— can be any data type: (primitive,non-primitive data types).
  â— way to tranfare data bettwen components
  â— only one way data-flow : from father-component to son-component()

ğŸ“Œ Why do we use it?
  â— reuse the same component with different values
  â— prop in father-component => write and read
  â— prop in son-component => readonly
  â— but if we want to change data internally in son-component we need to use : state & hooks

ğŸ“Œ What is prop drillin?
  â— problem happens when transfer prop bettwen more than 2 level

ğŸ“Œ How do we use it?
- syntax :
  â— import child component in parent-code-page
  â— inside parent component => inside return => inside opening tag of <Child> Enter the name of the prop and assign it a value.
  â— Create a parameter(props) in a child component
    // props => object contains all the values that the parent passed to the child.
  â— use those props inside child component by {props.propName}
<pre>
function Parent() {
  const data = "Hello from Parent"; // Ù…Ø«Ø§Ù„ Ø¹Ù„Ù‰ Ø§Ù„Ø¯Ø§ØªØ§
  return (
    &lt;div&gt;
      &lt;Child 
      data={data} 
      name='Ahmed'
      /&gt;
    &lt;/div&gt;
  )
}
-------------------------------------------------------

function Child(props) { 
  return (
    &lt;div&gt;
      {props.data} - {props.name}
    &lt;/div&gt;
  )
}
</pre>

  â— If you want to retrieve specific values directly instead of writing props.data, use destructuring:
<pre>
function Child({ data, name }) { 
  return (
    &lt;div&gt;
      {data} - {name}
    &lt;/div&gt;
  )
}
-------------------------------------------------------
function Parent() {
  const data = "Hello from Parent"; // Ù…Ø«Ø§Ù„ Ø¹Ù„Ù‰ Ø§Ù„Ø¯Ø§ØªØ§
  return (
    &lt;div&gt;
      &lt;Child 
      data={data} 
      name='Ahmed'
      /&gt;
    &lt;/div&gt;
  )
}
</pre>
â— Changing prop data internally by Child using State â†’ Each child maintains its own local copy of the data.
<pre>
export default function Parent() {
  const data = "Hello from Parent";

  return (
    &lt;div&gt;
      &lt;Child initialData={data} /&gt;
    &lt;/div&gt;
  );
}
-------------------------------------------------------
import { useState } from "react";

function Child({ initialData }) {
  const [data, setData] = useState(initialData);

  return (
    &lt;div&gt;
      &lt;p&gt;Data: {data}&lt;/p&gt;
      &lt;button onClick={() => setData("Changed in Child")}&gt;
        Change in Child
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
</pre>
  â— Changing prop data publicly by Parent using setState function as prop â†’ Child triggers updates to Parent's state, affecting all childs using that state.
<pre>
export default function Parent() {
  const [data, setData] = useState("Hello from Parent");

  return (
    &lt;div&gt;
      &lt;Child data={data} changeData={setData} /&gt;
    &lt;/div&gt;
  );
}
-------------------------------------------------------
import { useState } from "react";

function Child1({ data, changeData }) {
  return (
    &lt;div&gt;
      &lt;p&gt;Data: {data}&lt;/p&gt;  // Hello from Parent
      &lt;button onClick={() => changeData("Child 1 changed")}&gt;
        Change in Parent
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
-------------------------------------------------------
function Child2({ data, changeData }) {
  return (
    &lt;div&gt;
      &lt;p&gt;Data: {data}&lt;/p&gt; // Child 1 changed
    &lt;/div&gt;
  );
}
</pre>

</pre>
<pre class="prew">
  what I learned to build :
    create Chat.jsx
</pre>
    <script>
    fetch("header.html")
      .then(res => res.text())
      .then(data => {
        document.getElementById("header").innerHTML = data;
      });
  </script>
</body>
</html>