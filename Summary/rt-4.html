<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="description" content="">
  <meta name="keywords" content="">
  <link rel="stylesheet" href="assets/Css/tetorial.css">
  <title>React 4</title>
</head>
<body>
 <div id="header"></div>
  <pre class="prew">
<h2>lazy initialization in useState</h2>
- When we create useState ➡️ React takes the initialValue and sets it to state.
- However: 
  ● If the initialValue is simple (like a number or a small array), no problem.
  ● If the initialValue is the result of a heavy calculation or a function call, it will run every time the component is re-render (even if state doesn't change!).
- 🟢 Example :
<pre>
import { useState } from 'react'

export default function Counter() {

  function heavyCalculation() {
    console.log("Heavy calculation running...");
    return 1000; // Assume it returned a number after a heavy calculation
  }

  const [count, setCount] = useState(heavyCalculation());

  return (
    &lt;div&gt;
    &lt;p&gt;{count}&lt;/p&gt;
    &lt;button onClick={() => setCount(c => c + 1)}&gt; + &lt;/button&gt;
    &lt;/div&gt;
  );
}
</pre >
  ● 🔍 What happens here?
    o ✅ On the first render, heavyCalculation() runs.
    o ❌ On every re-render (due to any other state), heavyCalculation() runs again unnecessarily.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------    
<h3>With Lazy Initialization</h3>
- if we want react doesn't execute initialValue every time re-render
- execute it only once at the first render, and then stores the value.
- 🔵 Example :
<pre>
import { useState } from 'react'

export default function Counter() {

  function heavyCalculation() {
    console.log("Heavy Calculation is running...");
    return 1000;
  }

  const [count, setCount] = useState(() => heavyCalculation());

  return (
    &lt;div&gt;
    &lt;p&gt;{count}&lt;/p&gt;
    &lt;button onClick={() => setCount(c => c + 1)}&gt; + &lt;/button&gt;
    &lt;/div&gt;
  );
}

</pre >
  ● 🔍 What happens here?
    o The first time the component is rendered, React will execute this function and return the value (1000).
    o Subsequent times (re-render) will not run it again.

- 📌 Summary
  ● useState(value): Calculates the value every render (even if it's not used).
  ● useState(() => value): Calculates it only once (lazy initialization).
  ● If the value is simple, the two are the same.
  ● If the value is heavy, it's better to use a function for performance.
<hr><!--------------------------------------------------------------------------------------------->
📌 What is prop?
  ● Prop = Short of Properties.
  ● can be any data type: (primitive,non-primitive data types).
  ● way to tranfare data bettwen components
  ● only one way data-flow : from father-component to son-component()

📌 Why do we use it?
  ● reuse the same component with different values
  ● prop in father-component => write and read
  ● prop in son-component => readonly
  ● but if we want to change data internally in son-component we need to use : state & hooks

📌 What is prop drillin?
  ● problem happens when transfer prop bettwen more than 2 level

📌 How do we use it?
- syntax :
  ● import child component in parent-code-page
  ● inside parent component => inside return => inside opening tag of <Child> Enter the name of the prop and assign it a value.
  ● Create a parameter(props) in a child component
    // props => object contains all the values that the parent passed to the child.
  ● use those props inside child component by {props.propName}
<pre>
function Parent() {
  const data = "Hello from Parent"; // مثال على الداتا
  return (
    &lt;div&gt;
      &lt;Child 
      data={data} 
      name='Ahmed'
      /&gt;
    &lt;/div&gt;
  )
}
-------------------------------------------------------

function Child(props) { 
  return (
    &lt;div&gt;
      {props.data} - {props.name}
    &lt;/div&gt;
  )
}
</pre>

  ● If you want to retrieve specific values directly instead of writing props.data, use destructuring:
<pre>
function Child({ data, name }) { 
  return (
    &lt;div&gt;
      {data} - {name}
    &lt;/div&gt;
  )
}
-------------------------------------------------------
function Parent() {
  const data = "Hello from Parent"; // مثال على الداتا
  return (
    &lt;div&gt;
      &lt;Child 
      data={data} 
      name='Ahmed'
      /&gt;
    &lt;/div&gt;
  )
}
</pre>
● Changing prop data internally by Child using State → Each child maintains its own local copy of the data.
<pre>
export default function Parent() {
  const data = "Hello from Parent";

  return (
    &lt;div&gt;
      &lt;Child initialData={data} /&gt;
    &lt;/div&gt;
  );
}
-------------------------------------------------------
import { useState } from "react";

function Child({ initialData }) {
  const [data, setData] = useState(initialData);

  return (
    &lt;div&gt;
      &lt;p&gt;Data: {data}&lt;/p&gt;
      &lt;button onClick={() => setData("Changed in Child")}&gt;
        Change in Child
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
</pre>
  ● Changing prop data publicly by Parent using setState function as prop → Child triggers updates to Parent's state, affecting all childs using that state.
<pre>
export default function Parent() {
  const [data, setData] = useState("Hello from Parent");

  return (
    &lt;div&gt;
      &lt;Child data={data} changeData={setData} /&gt;
    &lt;/div&gt;
  );
}
-------------------------------------------------------
import { useState } from "react";

function Child1({ data, changeData }) {
  return (
    &lt;div&gt;
      &lt;p&gt;Data: {data}&lt;/p&gt;  // Hello from Parent
      &lt;button onClick={() => changeData("Child 1 changed")}&gt;
        Change in Parent
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
-------------------------------------------------------
function Child2({ data, changeData }) {
  return (
    &lt;div&gt;
      &lt;p&gt;Data: {data}&lt;/p&gt; // Child 1 changed
    &lt;/div&gt;
  );
}
</pre>

</pre>
<pre class="prew">
  what I learned to build :
    create Chat.jsx
</pre>
    <script>
    fetch("header.html")
      .then(res => res.text())
      .then(data => {
        document.getElementById("header").innerHTML = data;
      });
  </script>
</body>
</html>