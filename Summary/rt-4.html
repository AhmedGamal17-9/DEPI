<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="description" content="">
  <meta name="keywords" content="">
  <link rel="stylesheet" href="assets/Css/tetorial.css">
  <title>React 4</title>
</head>
<body>
 <div id="header"></div>
  <pre class="prew">
<h2>lazy initialization in useState</h2>
- When we create useState â¡ï¸ React takes the initialValue and sets it to state.
- However: 
  â— If the initialValue is simple (like a number or a small array), no problem.
  â— If the initialValue is the result of a heavy calculation or a function call, it will run every time the component is re-render (even if state doesn't change!).
- ğŸŸ¢ Example :
<pre>
import { useState } from 'react'

export default function Counter() {

  function heavyCalculation() {
    console.log("Heavy calculation running...");
    return 1000; // Assume it returned a number after a heavy calculation
  }

  const [count, setCount] = useState(heavyCalculation());

  return (
    &lt;div&gt;
    &lt;p&gt;{count}&lt;/p&gt;
    &lt;button onClick={() => setCount(c => c + 1)}&gt; + &lt;/button&gt;
    &lt;/div&gt;
  );
}
</pre >
  â— ğŸ” What happens here?
    o âœ… On the first render, heavyCalculation() runs.
    o âŒ On every re-render (due to any other state), heavyCalculation() runs again unnecessarily.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------    
<h3>With Lazy Initialization</h3>
- if we want react doesn't execute initialValue every time re-render
- execute it only once at the first render, and then stores the value.
- ğŸ”µ Example :
<pre>
import { useState } from 'react'

export default function Counter() {

  function heavyCalculation() {
    console.log("Heavy Calculation is running...");
    return 1000;
  }

  const [count, setCount] = useState(() => heavyCalculation());

  return (
    &lt;div&gt;
    &lt;p&gt;{count}&lt;/p&gt;
    &lt;button onClick={() => setCount(c => c + 1)}&gt; + &lt;/button&gt;
    &lt;/div&gt;
  );
}

</pre >
  â— ğŸ” What happens here?
    o The first time the component is rendered, React will execute this function and return the value (1000).
    o Subsequent times (re-render) will not run it again.

- ğŸ“Œ Summary
  â— useState(value): Calculates the value every render (even if it's not used).
  â— useState(() => value): Calculates it only once (lazy initialization).
  â— If the value is simple, the two are the same.
  â— If the value is heavy, it's better to use a function for performance.
<hr><!--------------------------------------------------------------------------------------------->
ğŸ“Œ What is prop?
  â— Prop = Short of Properties.
  â— can be any data type: (primitive,non-primitive data types).
  â— way to tranfare data bettwen components
  â— only one way data-flow : from father-component to son-component()

ğŸ“Œ Why do we use it?
  â— reuse the same component with different values
  â— prop in father-component => write and read
  â— prop in son-component => readonly
  â— but if we want to change data internally in son-component we need to use : state & hooks

ğŸ“Œ What is prop drillin?
  â— problem happens when transfer prop bettwen more than 2 level

ğŸ“Œ How do we use it?
- syntax :
  â— import child component in parent-code-page
  â— inside parent component => inside return => inside opening tag of <Child> Enter the name of the prop and assign it a value.
  â— Create a parameter(props) in a child component
    // props => object contains all the values that the parent passed to the child.
  â— use those props inside child component by {props.propName}
<pre>
function Parent() {
  const data = "Hello from Parent"; // Ù…Ø«Ø§Ù„ Ø¹Ù„Ù‰ Ø§Ù„Ø¯Ø§ØªØ§
  return (
    &lt;div&gt;
      &lt;Child 
      data={data} 
      name='Ahmed'
      /&gt;
    &lt;/div&gt;
  )
}
-------------------------------------------------------

function Child(props) { 
  return (
    &lt;div&gt;
      {props.data} - {props.name}
    &lt;/div&gt;
  )
}
</pre>

  â— If you want to retrieve specific values directly instead of writing props.data, use destructuring:
<pre>
function Child({ data, name }) { 
  return (
    &lt;div&gt;
      {data} - {name}
    &lt;/div&gt;
  )
}
-------------------------------------------------------
function Parent() {
  const data = "Hello from Parent"; // Ù…Ø«Ø§Ù„ Ø¹Ù„Ù‰ Ø§Ù„Ø¯Ø§ØªØ§
  return (
    &lt;div&gt;
      &lt;Child 
      data={data} 
      name='Ahmed'
      /&gt;
    &lt;/div&gt;
  )
}
</pre>
â— Changing prop data internally by Child using State â†’ Each child maintains its own local copy of the data.
<pre>
export default function Parent() {
  const data = "Hello from Parent";

  return (
    &lt;div&gt;
      &lt;Child initialData={data} /&gt;
    &lt;/div&gt;
  );
}
-------------------------------------------------------
import { useState } from "react";

function Child({ initialData }) {
  const [data, setData] = useState(initialData);

  return (
    &lt;div&gt;
      &lt;p&gt;Data: {data}&lt;/p&gt;
      &lt;button onClick={() => setData("Changed in Child")}&gt;
        Change in Child
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
</pre>
  â— Changing prop data publicly by Parent using setState function as prop â†’ Child triggers updates to Parent's state, affecting all childs using that state.
<pre>
export default function Parent() {
  const [data, setData] = useState("Hello from Parent");

  return (
    &lt;div&gt;
      &lt;Child data={data} changeData={setData} /&gt;
    &lt;/div&gt;
  );
}
-------------------------------------------------------
import { useState } from "react";

function Child1({ data, changeData }) {
  return (
    &lt;div&gt;
      &lt;p&gt;Data: {data}&lt;/p&gt;  // Hello from Parent
      &lt;button onClick={() => changeData("Child 1 changed")}&gt;
        Change in Parent
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
-------------------------------------------------------
function Child2({ data, changeData }) {
  return (
    &lt;div&gt;
      &lt;p&gt;Data: {data}&lt;/p&gt; // Child 1 changed
    &lt;/div&gt;
  );
}
</pre>
<hr><!--------------------------------------------------------------------------------------------->
ğŸ“Œ What is useEffect?
  â— It is a Hook that allows you to perform side effects in functional componentsAfter rendering or when certain values change.
  â— Side effects are operations that occur outside the normal flow of data in the component.
  â— Side effects are any operation that occurs "outside" the main UI.
  â— Examples of side effects:
    o Data fetching (API calls).
    o Subscribing to events (window.addEventListener, window resize, scroll).
    o Directly manipulating the DOM.
    o Running a timer (setInterval, setTimeout).
    o Handling localStorage.

ğŸ“Œ Why do we use it?
  â— Without useEffect, any code you put in a component's function will be executed immediately every time a render occurs, which can cause problems:
    o An infinite loop occurs (for example, fetching data causes => change in state, causing => re-render component forever).
    o Difficulty controlling when the code runs and when it stops.
  â— useEffect helps you tell React:
    o Run this code after rendering.
    o Run this code only the first time.
    o Run this code every time a certain value changes.

ğŸ“Œ How do we use it?
  â— Syntax : useEffect(callback function, dependency array)
    o callback function: This function contains the logic for the side effect.
    o dependency array: This array controls when the effect runs. 
  â— If the dependency array is:
    o Not provided: The effect runs after every render.
    o An empty array []: The effect runs only once after the initial render (like componentDidMount).
    o Contains values [prop1, state2]: The effect runs after the initial render and whenever any of the values in the dependency array change.

ğŸ“Œ What is Cleanup function? 
  â— If your effect needs to clean up resources ( unsubscribe from an event, clear a timer, WebSocket Subscription).
  â— you can return a cleanup-function in the callback function to do it.
  â— This cleanup function runs
    o before the component unmounts
                  OR
    o before the effect runs again due to a dependency change  

ğŸ”¹ Why do we need it?
  â— Prevent resource consumption
  â— Prevent memory leaks (unnecessary memory consumption).
  â— Life Analogy ğŸ  : Imagine you entered a room and turned on the light.
    o useEffect = You turned on the light.
    o Cleanup = Before you leave, you must turn off the light so it doesn't stay on for nothing.
<pre>
import { useEffect, useState } from 'react';

function Timer() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    // This effect runs once after the initial render (empty dependency array)
    const intervalId = setInterval(() => {
      setCount(prevCount => prevCount + 1);
    }, 1000);

    // Cleanup function: This runs once when the component unmounts
    return () => {
      clearInterval(intervalId);
    };
  }, []); // Empty dependency array means all code runs once

  return (
    &lt;div&gt;
      &lt;p&gt;Timer: {count} seconds&lt;/p&gt;
    &lt;/div&gt;
  );
}
</pre>
</pre>
<pre class="prew">
  what I learned to build :
    create Chat.jsx
</pre>
    <script>
    fetch("header.html")
      .then(res => res.text())
      .then(data => {
        document.getElementById("header").innerHTML = data;
      });
  </script>
</body>
</html>